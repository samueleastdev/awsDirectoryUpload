import { __awaiter, __generator } from "tslib";
export var memoize = function (provider, isExpired, requiresRefresh) {
    var resolved;
    var pending;
    var hasResult;
    // Wrapper over supplied provider with side effect to handle concurrent invocation.
    var coalesceProvider = function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!pending) {
                        pending = provider();
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, pending];
                case 2:
                    resolved = _a.sent();
                    hasResult = true;
                    return [3 /*break*/, 4];
                case 3:
                    pending = undefined;
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/, resolved];
            }
        });
    }); };
    if (isExpired === undefined) {
        // This is a static memoization; no need to incorporate refreshing
        return function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!hasResult) return [3 /*break*/, 2];
                        return [4 /*yield*/, coalesceProvider()];
                    case 1:
                        resolved = _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, resolved];
                }
            });
        }); };
    }
    var isConstant = false;
    return function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!!hasResult) return [3 /*break*/, 2];
                    return [4 /*yield*/, coalesceProvider()];
                case 1:
                    resolved = _a.sent();
                    _a.label = 2;
                case 2:
                    if (isConstant) {
                        return [2 /*return*/, resolved];
                    }
                    if (requiresRefresh && !requiresRefresh(resolved)) {
                        isConstant = true;
                        return [2 /*return*/, resolved];
                    }
                    if (!isExpired(resolved)) return [3 /*break*/, 4];
                    return [4 /*yield*/, coalesceProvider()];
                case 3:
                    _a.sent();
                    return [2 /*return*/, resolved];
                case 4: return [2 /*return*/, resolved];
            }
        });
    }); };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVtb2l6ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tZW1vaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUEwQ0EsTUFBTSxDQUFDLElBQU0sT0FBTyxHQUFvQixVQUN0QyxRQUFxQixFQUNyQixTQUFvQyxFQUNwQyxlQUEwQztJQUUxQyxJQUFJLFFBQVcsQ0FBQztJQUNoQixJQUFJLE9BQStCLENBQUM7SUFDcEMsSUFBSSxTQUFrQixDQUFDO0lBQ3ZCLG1GQUFtRjtJQUNuRixJQUFNLGdCQUFnQixHQUFnQjs7OztvQkFDcEMsSUFBSSxDQUFDLE9BQU8sRUFBRTt3QkFDWixPQUFPLEdBQUcsUUFBUSxFQUFFLENBQUM7cUJBQ3RCOzs7O29CQUVZLHFCQUFNLE9BQU8sRUFBQTs7b0JBQXhCLFFBQVEsR0FBRyxTQUFhLENBQUM7b0JBQ3pCLFNBQVMsR0FBRyxJQUFJLENBQUM7OztvQkFFakIsT0FBTyxHQUFHLFNBQVMsQ0FBQzs7d0JBRXRCLHNCQUFPLFFBQVEsRUFBQzs7O1NBQ2pCLENBQUM7SUFFRixJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7UUFDM0Isa0VBQWtFO1FBQ2xFLE9BQU87Ozs7NkJBQ0QsQ0FBQyxTQUFTLEVBQVYsd0JBQVU7d0JBQ0QscUJBQU0sZ0JBQWdCLEVBQUUsRUFBQTs7d0JBQW5DLFFBQVEsR0FBRyxTQUF3QixDQUFDOzs0QkFFdEMsc0JBQU8sUUFBUSxFQUFDOzs7YUFDakIsQ0FBQztLQUNIO0lBRUQsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO0lBRXZCLE9BQU87Ozs7eUJBQ0QsQ0FBQyxTQUFTLEVBQVYsd0JBQVU7b0JBQ0QscUJBQU0sZ0JBQWdCLEVBQUUsRUFBQTs7b0JBQW5DLFFBQVEsR0FBRyxTQUF3QixDQUFDOzs7b0JBRXRDLElBQUksVUFBVSxFQUFFO3dCQUNkLHNCQUFPLFFBQVEsRUFBQztxQkFDakI7b0JBRUQsSUFBSSxlQUFlLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLEVBQUU7d0JBQ2pELFVBQVUsR0FBRyxJQUFJLENBQUM7d0JBQ2xCLHNCQUFPLFFBQVEsRUFBQztxQkFDakI7eUJBQ0csU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFuQix3QkFBbUI7b0JBQ3JCLHFCQUFNLGdCQUFnQixFQUFFLEVBQUE7O29CQUF4QixTQUF3QixDQUFDO29CQUN6QixzQkFBTyxRQUFRLEVBQUM7d0JBRWxCLHNCQUFPLFFBQVEsRUFBQzs7O1NBQ2pCLENBQUM7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAYXdzLXNkay90eXBlc1wiO1xuXG5pbnRlcmZhY2UgTWVtb2l6ZU92ZXJsb2FkIHtcbiAgLyoqXG4gICAqXG4gICAqIERlY29yYXRlcyBhIHByb3ZpZGVyIGZ1bmN0aW9uIHdpdGggZWl0aGVyIHN0YXRpYyBtZW1vaXphdGlvbi5cbiAgICpcbiAgICogVG8gY3JlYXRlIGEgc3RhdGljYWxseSBtZW1vaXplZCBwcm92aWRlciwgc3VwcGx5IGEgcHJvdmlkZXIgYXMgdGhlIG9ubHlcbiAgICogYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvbi4gVGhlIHByb3ZpZGVyIHdpbGwgYmUgaW52b2tlZCBvbmNlLCBhbmQgYWxsXG4gICAqIGludm9jYXRpb25zIG9mIHRoZSBwcm92aWRlciByZXR1cm5lZCBieSBgbWVtb2l6ZWAgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAgICogcHJvbWlzZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlciBUaGUgcHJvdmlkZXIgd2hvc2UgcmVzdWx0IHNob3VsZCBiZSBjYWNoZWQgaW5kZWZpbml0ZWx5LlxuICAgKi9cbiAgPFQ+KHByb3ZpZGVyOiBQcm92aWRlcjxUPik6IFByb3ZpZGVyPFQ+O1xuXG4gIC8qKlxuICAgKiBEZWNvcmF0ZXMgYSBwcm92aWRlciBmdW5jdGlvbiB3aXRoIHJlZnJlc2hpbmcgbWVtb2l6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlciAgICAgICAgICBUaGUgcHJvdmlkZXIgd2hvc2UgcmVzdWx0IHNob3VsZCBiZSBjYWNoZWQuXG4gICAqIEBwYXJhbSBpc0V4cGlyZWQgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBldmFsdWF0ZSB0aGUgcmVzb2x2ZWQgdmFsdWUgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaWYgaXQgaXMgZXhwaXJlZC4gRm9yIGV4YW1wbGUsIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemluZyBBV1MgY3JlZGVudGlhbCBwcm92aWRlcnMsIHRoaXMgZnVuY3Rpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZCByZXR1cm4gYHRydWVgIHdoZW4gdGhlIGNyZWRlbnRpYWwnc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJhdGlvbiBpcyBpbiB0aGUgcGFzdCAob3IgdmVyeSBuZWFyIGZ1dHVyZSkgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHJlcXVpcmVzUmVmcmVzaCAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV2YWx1YXRlIHRoZSByZXNvbHZlZCB2YWx1ZSBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZSBpZiBpdCByZXByZXNlbnRzIHN0YXRpYyB2YWx1ZSBvciBvbmUgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgcmVmcmVzaGVkLiBGb3IgZXhhbXBsZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFXUyBjcmVkZW50aWFscyB0aGF0IGhhdmUgbm8gZGVmaW5lZCBleHBpcmF0aW9uIHdpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG5ldmVyIG5lZWQgdG8gYmUgcmVmcmVzaGVkLCBzbyB0aGlzIGZ1bmN0aW9uIHdvdWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHRydWVgIGlmIHRoZSBjcmVkZW50aWFscyByZXNvbHZlZCBieSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybHlpbmcgcHJvdmlkZXIgaGFkIGFuIGV4cGlyYXRpb24gYW5kIGBmYWxzZWBcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyd2lzZS5cbiAgICovXG4gIDxUPihcbiAgICBwcm92aWRlcjogUHJvdmlkZXI8VD4sXG4gICAgaXNFeHBpcmVkOiAocmVzb2x2ZWQ6IFQpID0+IGJvb2xlYW4sXG4gICAgcmVxdWlyZXNSZWZyZXNoPzogKHJlc29sdmVkOiBUKSA9PiBib29sZWFuXG4gICk6IFByb3ZpZGVyPFQ+O1xufVxuXG5leHBvcnQgY29uc3QgbWVtb2l6ZTogTWVtb2l6ZU92ZXJsb2FkID0gPFQ+KFxuICBwcm92aWRlcjogUHJvdmlkZXI8VD4sXG4gIGlzRXhwaXJlZD86IChyZXNvbHZlZDogVCkgPT4gYm9vbGVhbixcbiAgcmVxdWlyZXNSZWZyZXNoPzogKHJlc29sdmVkOiBUKSA9PiBib29sZWFuXG4pOiBQcm92aWRlcjxUPiA9PiB7XG4gIGxldCByZXNvbHZlZDogVDtcbiAgbGV0IHBlbmRpbmc6IFByb21pc2U8VD4gfCB1bmRlZmluZWQ7XG4gIGxldCBoYXNSZXN1bHQ6IGJvb2xlYW47XG4gIC8vIFdyYXBwZXIgb3ZlciBzdXBwbGllZCBwcm92aWRlciB3aXRoIHNpZGUgZWZmZWN0IHRvIGhhbmRsZSBjb25jdXJyZW50IGludm9jYXRpb24uXG4gIGNvbnN0IGNvYWxlc2NlUHJvdmlkZXI6IFByb3ZpZGVyPFQ+ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHByb3ZpZGVyKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZCA9IGF3YWl0IHBlbmRpbmc7XG4gICAgICBoYXNSZXN1bHQgPSB0cnVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH07XG5cbiAgaWYgKGlzRXhwaXJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN0YXRpYyBtZW1vaXphdGlvbjsgbm8gbmVlZCB0byBpbmNvcnBvcmF0ZSByZWZyZXNoaW5nXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghaGFzUmVzdWx0KSB7XG4gICAgICAgIHJlc29sdmVkID0gYXdhaXQgY29hbGVzY2VQcm92aWRlcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH07XG4gIH1cblxuICBsZXQgaXNDb25zdGFudCA9IGZhbHNlO1xuXG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFoYXNSZXN1bHQpIHtcbiAgICAgIHJlc29sdmVkID0gYXdhaXQgY29hbGVzY2VQcm92aWRlcigpO1xuICAgIH1cbiAgICBpZiAoaXNDb25zdGFudCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cblxuICAgIGlmIChyZXF1aXJlc1JlZnJlc2ggJiYgIXJlcXVpcmVzUmVmcmVzaChyZXNvbHZlZCkpIHtcbiAgICAgIGlzQ29uc3RhbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaXNFeHBpcmVkKHJlc29sdmVkKSkge1xuICAgICAgYXdhaXQgY29hbGVzY2VQcm92aWRlcigpO1xuICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH07XG59O1xuIl19