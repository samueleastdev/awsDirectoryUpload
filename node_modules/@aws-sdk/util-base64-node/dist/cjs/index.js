"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBase64 = exports.fromBase64 = void 0;
const util_buffer_from_1 = require("@aws-sdk/util-buffer-from");
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
/**
 * Converts a base-64 encoded string to a Uint8Array of bytes using Node.JS's
 * `buffer` module.
 *
 * @param input The base-64 encoded string
 */
function fromBase64(input) {
    // Node's buffer module allows padding to be omitted, but we want to enforce
    // it. So here we ensure that the input represents a number of bits divisible
    // by 8. Each character represents 6 bits, so after reducing the fraction we
    // end up mulitplying by 3/4 and checking for a remainder.
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    // Node will just ingore invalid characters, so we need to make sure they're
    // properly rejected.
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = util_buffer_from_1.fromString(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
exports.fromBase64 = fromBase64;
/**
 * Converts a Uint8Array of binary data to a base-64 encoded string using
 * Node.JS's `buffer` module.
 *
 * @param input The binary data to encode
 */
function toBase64(input) {
    return util_buffer_from_1.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("base64");
}
exports.toBase64 = toBase64;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsZ0VBQXdFO0FBRXhFLE1BQU0sWUFBWSxHQUFHLHdCQUF3QixDQUFDO0FBRTlDOzs7OztHQUtHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLEtBQWE7SUFDdEMsNEVBQTRFO0lBQzVFLDZFQUE2RTtJQUM3RSw0RUFBNEU7SUFDNUUsMERBQTBEO0lBQzFELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0tBQzVEO0lBRUQsNEVBQTRFO0lBQzVFLHFCQUFxQjtJQUNyQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM3QixNQUFNLElBQUksU0FBUyxDQUFDLHdCQUF3QixDQUFDLENBQUM7S0FDL0M7SUFFRCxNQUFNLE1BQU0sR0FBRyw2QkFBVSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztJQUUzQyxPQUFPLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDN0UsQ0FBQztBQWxCRCxnQ0FrQkM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxLQUFpQjtJQUN4QyxPQUFPLGtDQUFlLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDOUYsQ0FBQztBQUZELDRCQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJvbUFycmF5QnVmZmVyLCBmcm9tU3RyaW5nIH0gZnJvbSBcIkBhd3Mtc2RrL3V0aWwtYnVmZmVyLWZyb21cIjtcblxuY29uc3QgQkFTRTY0X1JFR0VYID0gL15bQS1aYS16MC05Ky9dKj17MCwyfSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzZS02NCBlbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgdXNpbmcgTm9kZS5KUydzXG4gKiBgYnVmZmVyYCBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGlucHV0IFRoZSBiYXNlLTY0IGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQmFzZTY0KGlucHV0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgLy8gTm9kZSdzIGJ1ZmZlciBtb2R1bGUgYWxsb3dzIHBhZGRpbmcgdG8gYmUgb21pdHRlZCwgYnV0IHdlIHdhbnQgdG8gZW5mb3JjZVxuICAvLyBpdC4gU28gaGVyZSB3ZSBlbnN1cmUgdGhhdCB0aGUgaW5wdXQgcmVwcmVzZW50cyBhIG51bWJlciBvZiBiaXRzIGRpdmlzaWJsZVxuICAvLyBieSA4LiBFYWNoIGNoYXJhY3RlciByZXByZXNlbnRzIDYgYml0cywgc28gYWZ0ZXIgcmVkdWNpbmcgdGhlIGZyYWN0aW9uIHdlXG4gIC8vIGVuZCB1cCBtdWxpdHBseWluZyBieSAzLzQgYW5kIGNoZWNraW5nIGZvciBhIHJlbWFpbmRlci5cbiAgaWYgKChpbnB1dC5sZW5ndGggKiAzKSAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbmNvcnJlY3QgcGFkZGluZyBvbiBiYXNlNjQgc3RyaW5nLmApO1xuICB9XG5cbiAgLy8gTm9kZSB3aWxsIGp1c3QgaW5nb3JlIGludmFsaWQgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhleSdyZVxuICAvLyBwcm9wZXJseSByZWplY3RlZC5cbiAgaWYgKCFCQVNFNjRfUkVHRVguZXhlYyhpbnB1dCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGJhc2U2NCBzdHJpbmcuYCk7XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBmcm9tU3RyaW5nKGlucHV0LCBcImJhc2U2NFwiKTtcblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgb2YgYmluYXJ5IGRhdGEgdG8gYSBiYXNlLTY0IGVuY29kZWQgc3RyaW5nIHVzaW5nXG4gKiBOb2RlLkpTJ3MgYGJ1ZmZlcmAgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBUaGUgYmluYXJ5IGRhdGEgdG8gZW5jb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jhc2U2NChpbnB1dDogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlTGVuZ3RoKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbiJdfQ==