import { strictParseByte, strictParseDouble, strictParseFloat32, strictParseShort } from "./parse-utils";
// Build indexes outside so we allocate them once.
var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
// These must be kept in order
// prettier-ignore
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
/**
 * Builds a proper UTC HttpDate timestamp from a Date object
 * since not all environments will have this as the expected
 * format.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString
 * > Prior to ECMAScript 2018, the format of the return value
 * > varied according to the platform. The most common return
 * > value was an RFC-1123 formatted date stamp, which is a
 * > slightly updated version of RFC-822 date stamps.
 */
export function dateToUtcString(date) {
    var year = date.getUTCFullYear();
    var month = date.getUTCMonth();
    var dayOfWeek = date.getUTCDay();
    var dayOfMonthInt = date.getUTCDate();
    var hoursInt = date.getUTCHours();
    var minutesInt = date.getUTCMinutes();
    var secondsInt = date.getUTCSeconds();
    // Build 0 prefixed strings for contents that need to be
    // two digits and where we get an integer back.
    var dayOfMonthString = dayOfMonthInt < 10 ? "0" + dayOfMonthInt : "" + dayOfMonthInt;
    var hoursString = hoursInt < 10 ? "0" + hoursInt : "" + hoursInt;
    var minutesString = minutesInt < 10 ? "0" + minutesInt : "" + minutesInt;
    var secondsString = secondsInt < 10 ? "0" + secondsInt : "" + secondsInt;
    return DAYS[dayOfWeek] + ", " + dayOfMonthString + " " + MONTHS[month] + " " + year + " " + hoursString + ":" + minutesString + ":" + secondsString + " GMT";
}
var RFC3339 = new RegExp(/^(?<Y>\d{4})-(?<M>\d{2})-(?<D>\d{2})[tT](?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))?[zZ]$/);
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC
 * offset. Fractional precision is supported.
 *
 * {@see https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
export var parseRfc3339DateTime = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    var match = RFC3339.exec(value);
    if (!match || !match.groups) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    var year = strictParseShort(stripLeadingZeroes(match.groups["Y"]));
    var month = parseDateValue(match.groups["M"], "month", 1, 12);
    var day = parseDateValue(match.groups["D"], "day", 1, 31);
    return buildDate(year, month, day, match);
};
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (?<D>\d{2}) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<Y>\d{4}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (?<D>\d{2})-(?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(?<Y>\d{2}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<D> [1-9]|\d{2}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? (?<Y>\d{4})$/);
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 IMF-fixdate or obs-date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * {@see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
export var parseRfc7231DateTime = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    //allow customization of day parsing for asctime days, which can be left-padded with spaces
    var dayFn = function (value) { return parseDateValue(value, "day", 1, 31); };
    //all formats other than RFC 850 use a four-digit year
    var yearFn = function (value) { return strictParseShort(stripLeadingZeroes(value)); };
    //RFC 850 dates need post-processing to adjust year values if they are too far in the future
    var dateAdjustmentFn = function (value) { return value; };
    var match = IMF_FIXDATE.exec(value);
    if (!match || !match.groups) {
        match = RFC_850_DATE.exec(value);
        if (match && match.groups) {
            // RFC 850 dates use 2-digit years. So we parse the year specifically,
            // and then once we've constructed the entire date, we adjust it if the resultant date
            // is too far in the future.
            yearFn = parseTwoDigitYear;
            dateAdjustmentFn = adjustRfc850Year;
        }
        else {
            match = ASC_TIME.exec(value);
            if (match && match.groups) {
                dayFn = function (value) { return parseDateValue(value.trimLeft(), "day", 1, 31); };
            }
            else {
                throw new TypeError("Invalid RFC-7231 date-time value");
            }
        }
    }
    var year = yearFn(match.groups["Y"]);
    var month = parseMonthByShortName(match.groups["M"]);
    var day = dayFn(match.groups["D"]);
    return dateAdjustmentFn(buildDate(year, month, day, match));
};
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
export var parseEpochTimestamp = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    var valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
/**
 * Build a date from a numeric year, month, date, and an match with named groups
 * "H", "m", s", and "frac", representing hours, minutes, seconds, and optional fractional seconds.
 * @param year numeric year
 * @param month numeric month, 1-indexed
 * @param day numeric year
 * @param match match with groups "H", "m", s", and "frac"
 */
var buildDate = function (year, month, day, match) {
    var adjustedMonth = month - 1; // JavaScript, and our internal data structures, expect 0-indexed months
    validateDayOfMonth(year, adjustedMonth, day);
    // Adjust month down by 1
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(match.groups["H"], "hour", 0, 23), parseDateValue(match.groups["m"], "minute", 0, 59), 
    // seconds can go up to 60 for leap seconds
    parseDateValue(match.groups["s"], "seconds", 0, 60), parseMilliseconds(match.groups["frac"])));
};
/**
 * RFC 850 dates use a 2-digit year; start with the assumption that if it doesn't
 * match the current year, then it's a date in the future, then let adjustRfc850Year adjust
 * the final date back to the past if it's too far in the future.
 *
 * Example: in 2021, start with the assumption that '11' is '2111', and that '22' is '2022'.
 * adjustRfc850Year will adjust '11' to 2011, (as 2111 is more than 50 years in the future),
 * but keep '22' as 2022. in 2099, '11' will represent '2111', but '98' should be '2098'.
 * There's no description of an RFC 850 date being considered too far in the past in RFC-7231,
 * so it's entirely possible that 2011 is a valid interpretation of '11' in 2099.
 * @param value the 2 digit year to parse
 * @return number a year that is equal to or greater than the current UTC year
 */
var parseTwoDigitYear = function (value) {
    var thisYear = new Date().getUTCFullYear();
    var valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        // This may end up returning a year that adjustRfc850Year turns back by 100.
        // That's fine! We don't know the other components of the date yet, so there are
        // boundary conditions that only adjustRfc850Year can handle.
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
/**
 * Adjusts the year value found in RFC 850 dates according to the rules
 * expressed in RFC7231, which state:
 *
 * <blockquote>Recipients of a timestamp value in rfc850-date format, which uses a
 * two-digit year, MUST interpret a timestamp that appears to be more
 * than 50 years in the future as representing the most recent year in
 * the past that had the same last two digits.</blockquote>
 *
 * @param input a Date that assumes the two-digit year was in the future
 * @return a Date that is in the past if input is > 50 years in the future
 */
var adjustRfc850Year = function (input) {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
var parseMonthByShortName = function (value) {
    var monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError("Invalid month: " + value);
    }
    return monthIdx + 1;
};
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/**
 * Validate the day is valid for the given month.
 * @param year the year
 * @param month the month (0-indexed)
 * @param day the day of the month
 */
var validateDayOfMonth = function (year, month, day) {
    var maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError("Invalid day for " + MONTHS[month] + " in " + year + ": " + day);
    }
};
var isLeapYear = function (year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var parseDateValue = function (value, type, lower, upper) {
    var dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(type + " must be between " + lower + " and " + upper + ", inclusive");
    }
    return dateVal;
};
var parseMilliseconds = function (value) {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
var stripLeadingZeroes = function (value) {
    var idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRlLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekcsa0RBQWtEO0FBQ2xELElBQU0sSUFBSSxHQUFrQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRTlFLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsSUFBTSxNQUFNLEdBQWtCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztBQUVuSDs7Ozs7Ozs7OztHQVVHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FBQyxJQUFVO0lBQ3hDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUNuQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDakMsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ25DLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN4QyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDcEMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3hDLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUV4Qyx3REFBd0Q7SUFDeEQsK0NBQStDO0lBQy9DLElBQU0sZ0JBQWdCLEdB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QU0sa0JBQWtCLEdBQUcsVUFBQyxLQUFhO0lBQ3ZDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNaLE9BQU8sR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFO1FBQzFELEdBQUcsRUFBRSxDQUFDO0tBQ1A7SUFDRCxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7UUFDYixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmljdFBhcnNlQnl0ZSwgc3RyaWN0UGFyc2VEb3VibGUsIHN0cmljdFBhcnNlRmxvYXQzMiwgc3RyaWN0UGFyc2VTaG9ydCB9IGZyb20gXCIuL3BhcnNlLXV0aWxzXCI7XG5cbi8vIEJ1aWxkIGluZGV4ZXMgb3V0c2lkZSBzbyB3ZSBhbGxvY2F0ZSB0aGVtIG9uY2UuXG5jb25zdCBEQVlTOiBBcnJheTxTdHJpbmc+ID0gW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdO1xuXG4vLyBUaGVzZSBtdXN0IGJlIGtlcHQgaW4gb3JkZXJcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgTU9OVEhTOiBBcnJheTxTdHJpbmc+ID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xuXG4vKipcbiAqIEJ1aWxkcyBhIHByb3BlciBVVEMgSHR0cERhdGUgdGltZXN0YW1wIGZyb20gYSBEYXRlIG9iamVjdFxuICogc2luY2Ugbm90IGFsbCBlbnZpcm9ubWVudHMgd2lsbCBoYXZlIHRoaXMgYXMgdGhlIGV4cGVjdGVkXG4gKiBmb3JtYXQuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvVVRDU3RyaW5nXG4gKiA+IFByaW9yIHRvIEVDTUFTY3JpcHQgMjAxOCwgdGhlIGZvcm1hdCBvZiB0aGUgcmV0dXJuIHZhbHVlXG4gKiA+IHZhcmllZCBhY2NvcmRpbmcgdG8gdGhlIHBsYXRmb3JtLiBUaGUgbW9zdCBjb21tb24gcmV0dXJuXG4gKiA+IHZhbHVlIHdhcyBhbiBSRkMtMTEyMyBmb3JtYXR0ZWQgZGF0ZSBzdGFtcCwgd2hpY2ggaXMgYVxuICogPiBzbGlnaHRseSB1cGRhdGVkIHZlcnNpb24gb2YgUkZDLTgyMiBkYXRlIHN0YW1wcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUb1V0Y1N0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgY29uc3QgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIGNvbnN0IGRheU9mTW9udGhJbnQgPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgY29uc3QgaG91cnNJbnQgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gIGNvbnN0IG1pbnV0ZXNJbnQgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgY29uc3Qgc2Vjb25kc0ludCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuXG4gIC8vIEJ1aWxkIDAgcHJlZml4ZWQgc3RyaW5ncyBmb3IgY29udGVudHMgdGhhdCBuZWVkIHRvIGJlXG4gIC8vIHR3byBkaWdpdHMgYW5kIHdoZXJlIHdlIGdldCBhbiBpbnRlZ2VyIGJhY2suXG4gIGNvbnN0IGRheU9mTW9udGhTdHJpbmcgPSBkYXlPZk1vbnRoSW50IDwgMTAgPyBgMCR7ZGF5T2ZNb250aEludH1gIDogYCR7ZGF5T2ZNb250aEludH1gO1xuICBjb25zdCBob3Vyc1N0cmluZyA9IGhvdXJzSW50IDwgMTAgPyBgMCR7aG91cnNJbnR9YCA6IGAke2hvdXJzSW50fWA7XG4gIGNvbnN0IG1pbnV0ZXNTdHJpbmcgPSBtaW51dGVzSW50IDwgMTAgPyBgMCR7bWludXRlc0ludH1gIDogYCR7bWludXRlc0ludH1gO1xuICBjb25zdCBzZWNvbmRzU3RyaW5nID0gc2Vjb25kc0ludCA8IDEwID8gYDAke3NlY29uZHNJbnR9YCA6IGAke3NlY29uZHNJbnR9YDtcblxuICByZXR1cm4gYCR7REFZU1tkYXlPZldlZWtdfSwgJHtkYXlPZk1vbnRoU3RyaW5nfSAke01PTlRIU1ttb250aF19ICR7eWVhcn0gJHtob3Vyc1N0cmluZ306JHttaW51dGVzU3RyaW5nfToke3NlY29uZHNTdHJpbmd9IEdNVGA7XG59XG5cbmNvbnN0IFJGQzMzMzkgPSBuZXcgUmVnRXhwKFxuICAvXig/PFk+XFxkezR9KS0oPzxNPlxcZHsyfSktKD88RD5cXGR7Mn0pW3RUXSg/PEg+XFxkezJ9KTooPzxtPlxcZHsyfSk6KD88cz5cXGR7Mn0pKD86XFwuKD88ZnJhYz5cXGQrKSk/W3paXSQvXG4pO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSBEYXRlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgaW5wdXQgaXMgbnVsbCBvclxuICogdW5kZWZpbmVkLCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBwYXJzZWRcbiAqIGFzIGFuIFJGQyAzMzM5IGRhdGUuXG4gKlxuICogSW5wdXQgc3RyaW5ncyBtdXN0IGNvbmZvcm0gdG8gUkZDMzMzOSBzZWN0aW9uIDUuNiwgYW5kIGNhbm5vdCBoYXZlIGEgVVRDXG4gKiBvZmZzZXQuIEZyYWN0aW9uYWwgcHJlY2lzaW9uIGlzIHN1cHBvcnRlZC5cbiAqXG4gKiB7QHNlZSBodHRwczovL3htbDJyZmMudG9vbHMuaWV0Zi5vcmcvcHVibGljL3JmYy9odG1sL3JmYzMzMzkuaHRtbCNhbmNob3IxNH1cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIGEgRGF0ZSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlUmZjMzMzOURhdGVUaW1lID0gKHZhbHVlOiB1bmtub3duKTogRGF0ZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJGQy0zMzM5IGRhdGUtdGltZXMgbXVzdCBiZSBleHByZXNzZWQgYXMgc3RyaW5nc1wiKTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IFJGQzMzMzkuZXhlYyh2YWx1ZSk7XG4gIGlmICghbWF0Y2ggfHwgIW1hdGNoLmdyb3Vwcykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFJGQy0zMzM5IGRhdGUtdGltZSB2YWx1ZVwiKTtcbiAgfVxuICBjb25zdCB5ZWFyID0gc3RyaWN0UGFyc2VTaG9ydChzdHJpcExlYWRpbmdaZXJvZXMobWF0Y2guZ3JvdXBzW1wiWVwiXSkpITtcbiAgY29uc3QgbW9udGggPSBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHNbXCJNXCJdLCBcIm1vbnRoXCIsIDEsIDEyKTtcbiAgY29uc3QgZGF5ID0gcGFyc2VEYXRlVmFsdWUobWF0Y2guZ3JvdXBzW1wiRFwiXSwgXCJkYXlcIiwgMSwgMzEpO1xuXG4gIHJldHVybiBidWlsZERhdGUoeWVhciwgbW9udGgsIGRheSwgbWF0Y2gpO1xufTtcblxuY29uc3QgSU1GX0ZJWERBVEUgPSBuZXcgUmVnRXhwKFxuICAvXig/Ok1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksICg/PEQ+XFxkezJ9KSAoPzxNPkphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoPzxZPlxcZHs0fSkgKD88SD5cXGR7Mn0pOig/PG0+XFxkezJ9KTooPzxzPlxcZHsyfSkoPzpcXC4oPzxmcmFjPlxcZCspKT8gR01UJC9cbik7XG5jb25zdCBSRkNfODUwX0RBVEUgPSBuZXcgUmVnRXhwKFxuICAvXig/Ok1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKD88RD5cXGR7Mn0pLSg/PE0+SmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLSg/PFk+XFxkezJ9KSAoPzxIPlxcZHsyfSk6KD88bT5cXGR7Mn0pOig/PHM+XFxkezJ9KSg/OlxcLig/PGZyYWM+XFxkKykpPyBHTVQkL1xuKTtcbmNvbnN0IEFTQ19USU1FID0gbmV3IFJlZ0V4cChcbiAgL14oPzpNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pICg/PE0+SmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICg/PEQ+IFsxLTldfFxcZHsyfSkgKD88SD5cXGR7Mn0pOig/PG0+XFxkezJ9KTooPzxzPlxcZHsyfSkoPzpcXC4oPzxmcmFjPlxcZCspKT8gKD88WT5cXGR7NH0pJC9cbik7XG5cbi8qKlxuICogUGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGUuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBpcyBudWxsIG9yXG4gKiB1bmRlZmluZWQsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nIHRoYXQgY2FuIGJlIHBhcnNlZFxuICogYXMgYW4gUkZDIDcyMzEgSU1GLWZpeGRhdGUgb3Igb2JzLWRhdGUuXG4gKlxuICogSW5wdXQgc3RyaW5ncyBtdXN0IGNvbmZvcm0gdG8gUkZDNzIzMSBzZWN0aW9uIDcuMS4xLjEuIEZyYWN0aW9uYWwgc2Vjb25kcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIHtAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzIzMS5odG1sI3NlY3Rpb24tNy4xLjEuMX1cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIGEgRGF0ZSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlUmZjNzIzMURhdGVUaW1lID0gKHZhbHVlOiB1bmtub3duKTogRGF0ZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJGQy03MjMxIGRhdGUtdGltZXMgbXVzdCBiZSBleHByZXNzZWQgYXMgc3RyaW5nc1wiKTtcbiAgfVxuXG4gIC8vYWxsb3cgY3VzdG9taXphdGlvbiBvZiBkYXkgcGFyc2luZyBmb3IgYXNjdGltZSBkYXlzLCB3aGljaCBjYW4gYmUgbGVmdC1wYWRkZWQgd2l0aCBzcGFjZXNcbiAgbGV0IGRheUZuOiAodmFsdWU6IHN0cmluZykgPT4gbnVtYmVyID0gKHZhbHVlKSA9PiBwYXJzZURhdGVWYWx1ZSh2YWx1ZSwgXCJkYXlcIiwgMSwgMzEpO1xuXG4gIC8vYWxsIGZvcm1hdHMgb3RoZXIgdGhhbiBSRkMgODUwIHVzZSBhIGZvdXItZGlnaXQgeWVhclxuICBsZXQgeWVhckZuOiAodmFsdWU6IHN0cmluZykgPT4gbnVtYmVyID0gKHZhbHVlOiBzdHJpbmcpID0+IHN0cmljdFBhcnNlU2hvcnQoc3RyaXBMZWFkaW5nWmVyb2VzKHZhbHVlKSkhO1xuICAvL1JGQyA4NTAgZGF0ZXMgbmVlZCBwb3N0LXByb2Nlc3NpbmcgdG8gYWRqdXN0IHllYXIgdmFsdWVzIGlmIHRoZXkgYXJlIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZVxuICBsZXQgZGF0ZUFkanVzdG1lbnRGbjogKHZhbHVlOiBEYXRlKSA9PiBEYXRlID0gKHZhbHVlKSA9PiB2YWx1ZTtcblxuICBsZXQgbWF0Y2ggPSBJTUZfRklYREFURS5leGVjKHZhbHVlKTtcbiAgaWYgKCFtYXRjaCB8fCAhbWF0Y2guZ3JvdXBzKSB7XG4gICAgbWF0Y2ggPSBSRkNfODUwX0RBVEUuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmdyb3Vwcykge1xuICAgICAgLy8gUkZDIDg1MCBkYXRlcyB1c2UgMi1kaWdpdCB5ZWFycy4gU28gd2UgcGFyc2UgdGhlIHllYXIgc3BlY2lmaWNhbGx5LFxuICAgICAgLy8gYW5kIHRoZW4gb25jZSB3ZSd2ZSBjb25zdHJ1Y3RlZCB0aGUgZW50aXJlIGRhdGUsIHdlIGFkanVzdCBpdCBpZiB0aGUgcmVzdWx0YW50IGRhdGVcbiAgICAgIC8vIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHllYXJGbiA9IHBhcnNlVHdvRGlnaXRZZWFyO1xuICAgICAgZGF0ZUFkanVzdG1lbnRGbiA9IGFkanVzdFJmYzg1MFllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gQVNDX1RJTUUuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZ3JvdXBzKSB7XG4gICAgICAgIGRheUZuID0gKHZhbHVlKSA9PiBwYXJzZURhdGVWYWx1ZSh2YWx1ZS50cmltTGVmdCgpLCBcImRheVwiLCAxLCAzMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBSRkMtNzIzMSBkYXRlLXRpbWUgdmFsdWVcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeWVhciA9IHllYXJGbihtYXRjaC5ncm91cHNbXCJZXCJdKTtcbiAgY29uc3QgbW9udGggPSBwYXJzZU1vbnRoQnlTaG9ydE5hbWUobWF0Y2guZ3JvdXBzW1wiTVwiXSk7XG4gIGNvbnN0IGRheSA9IGRheUZuKG1hdGNoLmdyb3Vwc1tcIkRcIl0pO1xuICByZXR1cm4gZGF0ZUFkanVzdG1lbnRGbihidWlsZERhdGUoeWVhciwgbW9udGgsIGRheSwgbWF0Y2gpKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGUuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBpcyBudWxsIG9yXG4gKiB1bmRlZmluZWQsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgaXMgbm90IGEgbnVtYmVyIG9yIGEgcGFyc2VhYmxlIHN0cmluZy5cbiAqXG4gKiBJbnB1dCBzdHJpbmdzIG11c3QgYmUgYW4gaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCBudW1iZXIuIEZyYWN0aW9uYWwgc2Vjb25kcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcGFyc2VcbiAqIEByZXR1cm4gYSBEYXRlIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgY29uc3QgcGFyc2VFcG9jaFRpbWVzdGFtcCA9ICh2YWx1ZTogdW5rbm93bik6IERhdGUgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBsZXQgdmFsdWVBc0RvdWJsZTogbnVtYmVyO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsdWVBc0RvdWJsZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbHVlQXNEb3VibGUgPSBzdHJpY3RQYXJzZURvdWJsZSh2YWx1ZSkhO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFcG9jaCB0aW1lc3RhbXBzIG11c3QgYmUgZXhwcmVzc2VkIGFzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgb3IgdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uXCIpO1xuICB9XG5cbiAgaWYgKE51bWJlci5pc05hTih2YWx1ZUFzRG91YmxlKSB8fCB2YWx1ZUFzRG91YmxlID09PSBJbmZpbml0eSB8fCB2YWx1ZUFzRG91YmxlID09PSAtSW5maW5pdHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXBvY2ggdGltZXN0YW1wcyBtdXN0IGJlIHZhbGlkLCBub24tSW5maW5pdGUsIG5vbi1OYU4gbnVtZXJpY3NcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQodmFsdWVBc0RvdWJsZSAqIDEwMDApKTtcbn07XG5cbi8qKlxuICogQnVpbGQgYSBkYXRlIGZyb20gYSBudW1lcmljIHllYXIsIG1vbnRoLCBkYXRlLCBhbmQgYW4gbWF0Y2ggd2l0aCBuYW1lZCBncm91cHNcbiAqIFwiSFwiLCBcIm1cIiwgc1wiLCBhbmQgXCJmcmFjXCIsIHJlcHJlc2VudGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG9wdGlvbmFsIGZyYWN0aW9uYWwgc2Vjb25kcy5cbiAqIEBwYXJhbSB5ZWFyIG51bWVyaWMgeWVhclxuICogQHBhcmFtIG1vbnRoIG51bWVyaWMgbW9udGgsIDEtaW5kZXhlZFxuICogQHBhcmFtIGRheSBudW1lcmljIHllYXJcbiAqIEBwYXJhbSBtYXRjaCBtYXRjaCB3aXRoIGdyb3VwcyBcIkhcIiwgXCJtXCIsIHNcIiwgYW5kIFwiZnJhY1wiXG4gKi9cbmNvbnN0IGJ1aWxkRGF0ZSA9ICh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBtYXRjaDogUmVnRXhwTWF0Y2hBcnJheSk6IERhdGUgPT4ge1xuICBjb25zdCBhZGp1c3RlZE1vbnRoID0gbW9udGggLSAxOyAvLyBKYXZhU2NyaXB0LCBhbmQgb3VyIGludGVybmFsIGRhdGEgc3RydWN0dXJlcywgZXhwZWN0IDAtaW5kZXhlZCBtb250aHNcbiAgdmFsaWRhdGVEYXlPZk1vbnRoKHllYXIsIGFkanVzdGVkTW9udGgsIGRheSk7XG4gIC8vIEFkanVzdCBtb250aCBkb3duIGJ5IDFcbiAgcmV0dXJuIG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgeWVhcixcbiAgICAgIGFkanVzdGVkTW9udGgsXG4gICAgICBkYXksXG4gICAgICBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHMhW1wiSFwiXSEsIFwiaG91clwiLCAwLCAyMyksXG4gICAgICBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHMhW1wibVwiXSEsIFwibWludXRlXCIsIDAsIDU5KSxcbiAgICAgIC8vIHNlY29uZHMgY2FuIGdvIHVwIHRvIDYwIGZvciBsZWFwIHNlY29uZHNcbiAgICAgIHBhcnNlRGF0ZVZhbHVlKG1hdGNoLmdyb3VwcyFbXCJzXCJdISwgXCJzZWNvbmRzXCIsIDAsIDYwKSxcbiAgICAgIHBhcnNlTWlsbGlzZWNvbmRzKG1hdGNoLmdyb3VwcyFbXCJmcmFjXCJdKVxuICAgIClcbiAgKTtcbn07XG5cbi8qKlxuICogUkZDIDg1MCBkYXRlcyB1c2UgYSAyLWRpZ2l0IHllYXI7IHN0YXJ0IHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpZiBpdCBkb2Vzbid0XG4gKiBtYXRjaCB0aGUgY3VycmVudCB5ZWFyLCB0aGVuIGl0J3MgYSBkYXRlIGluIHRoZSBmdXR1cmUsIHRoZW4gbGV0IGFkanVzdFJmYzg1MFllYXIgYWRqdXN0XG4gKiB0aGUgZmluYWwgZGF0ZSBiYWNrIHRvIHRoZSBwYXN0IGlmIGl0J3MgdG9vIGZhciBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEV4YW1wbGU6IGluIDIwMjEsIHN0YXJ0IHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCAnMTEnIGlzICcyMTExJywgYW5kIHRoYXQgJzIyJyBpcyAnMjAyMicuXG4gKiBhZGp1c3RSZmM4NTBZZWFyIHdpbGwgYWRqdXN0ICcxMScgdG8gMjAxMSwgKGFzIDIxMTEgaXMgbW9yZSB0aGFuIDUwIHllYXJzIGluIHRoZSBmdXR1cmUpLFxuICogYnV0IGtlZXAgJzIyJyBhcyAyMDIyLiBpbiAyMDk5LCAnMTEnIHdpbGwgcmVwcmVzZW50ICcyMTExJywgYnV0ICc5OCcgc2hvdWxkIGJlICcyMDk4Jy5cbiAqIFRoZXJlJ3Mgbm8gZGVzY3JpcHRpb24gb2YgYW4gUkZDIDg1MCBkYXRlIGJlaW5nIGNvbnNpZGVyZWQgdG9vIGZhciBpbiB0aGUgcGFzdCBpbiBSRkMtNzIzMSxcbiAqIHNvIGl0J3MgZW50aXJlbHkgcG9zc2libGUgdGhhdCAyMDExIGlzIGEgdmFsaWQgaW50ZXJwcmV0YXRpb24gb2YgJzExJyBpbiAyMDk5LlxuICogQHBhcmFtIHZhbHVlIHRoZSAyIGRpZ2l0IHllYXIgdG8gcGFyc2VcbiAqIEByZXR1cm4gbnVtYmVyIGEgeWVhciB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBVVEMgeWVhclxuICovXG5jb25zdCBwYXJzZVR3b0RpZ2l0WWVhciA9ICh2YWx1ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgY29uc3QgdGhpc1llYXIgPSBuZXcgRGF0ZSgpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIGNvbnN0IHZhbHVlSW5UaGlzQ2VudHVyeSA9IE1hdGguZmxvb3IodGhpc1llYXIgLyAxMDApICogMTAwICsgc3RyaWN0UGFyc2VTaG9ydChzdHJpcExlYWRpbmdaZXJvZXModmFsdWUpKSE7XG4gIGlmICh2YWx1ZUluVGhpc0NlbnR1cnkgPCB0aGlzWWVhcikge1xuICAgIC8vIFRoaXMgbWF5IGVuZCB1cCByZXR1cm5pbmcgYSB5ZWFyIHRoYXQgYWRqdXN0UmZjODUwWWVhciB0dXJucyBiYWNrIGJ5IDEwMC5cbiAgICAvLyBUaGF0J3MgZmluZSEgV2UgZG9uJ3Qga25vdyB0aGUgb3RoZXIgY29tcG9uZW50cyBvZiB0aGUgZGF0ZSB5ZXQsIHNvIHRoZXJlIGFyZVxuICAgIC8vIGJvdW5kYXJ5IGNvbmRpdGlvbnMgdGhhdCBvbmx5IGFkanVzdFJmYzg1MFllYXIgY2FuIGhhbmRsZS5cbiAgICByZXR1cm4gdmFsdWVJblRoaXNDZW50dXJ5ICsgMTAwO1xuICB9XG4gIHJldHVybiB2YWx1ZUluVGhpc0NlbnR1cnk7XG59O1xuXG5jb25zdCBGSUZUWV9ZRUFSU19JTl9NSUxMSVMgPSA1MCAqIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgeWVhciB2YWx1ZSBmb3VuZCBpbiBSRkMgODUwIGRhdGVzIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAqIGV4cHJlc3NlZCBpbiBSRkM3MjMxLCB3aGljaCBzdGF0ZTpcbiAqXG4gKiA8YmxvY2txdW90ZT5SZWNpcGllbnRzIG9mIGEgdGltZXN0YW1wIHZhbHVlIGluIHJmYzg1MC1kYXRlIGZvcm1hdCwgd2hpY2ggdXNlcyBhXG4gKiB0d28tZGlnaXQgeWVhciwgTVVTVCBpbnRlcnByZXQgYSB0aW1lc3RhbXAgdGhhdCBhcHBlYXJzIHRvIGJlIG1vcmVcbiAqIHRoYW4gNTAgeWVhcnMgaW4gdGhlIGZ1dHVyZSBhcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgcmVjZW50IHllYXIgaW5cbiAqIHRoZSBwYXN0IHRoYXQgaGFkIHRoZSBzYW1lIGxhc3QgdHdvIGRpZ2l0cy48L2Jsb2NrcXVvdGU+XG4gKlxuICogQHBhcmFtIGlucHV0IGEgRGF0ZSB0aGF0IGFzc3VtZXMgdGhlIHR3by1kaWdpdCB5ZWFyIHdhcyBpbiB0aGUgZnV0dXJlXG4gKiBAcmV0dXJuIGEgRGF0ZSB0aGF0IGlzIGluIHRoZSBwYXN0IGlmIGlucHV0IGlzID4gNTAgeWVhcnMgaW4gdGhlIGZ1dHVyZVxuICovXG5jb25zdCBhZGp1c3RSZmM4NTBZZWFyID0gKGlucHV0OiBEYXRlKTogRGF0ZSA9PiB7XG4gIGlmIChpbnB1dC5nZXRUaW1lKCkgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IEZJRlRZX1lFQVJTX0lOX01JTExJUykge1xuICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgIERhdGUuVVRDKFxuICAgICAgICBpbnB1dC5nZXRVVENGdWxsWWVhcigpIC0gMTAwLFxuICAgICAgICBpbnB1dC5nZXRVVENNb250aCgpLFxuICAgICAgICBpbnB1dC5nZXRVVENEYXRlKCksXG4gICAgICAgIGlucHV0LmdldFVUQ0hvdXJzKCksXG4gICAgICAgIGlucHV0LmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgaW5wdXQuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBpbnB1dC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgcGFyc2VNb250aEJ5U2hvcnROYW1lID0gKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBjb25zdCBtb250aElkeCA9IE1PTlRIUy5pbmRleE9mKHZhbHVlKTtcbiAgaWYgKG1vbnRoSWR4IDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbW9udGg6ICR7dmFsdWV9YCk7XG4gIH1cbiAgcmV0dXJuIG1vbnRoSWR4ICsgMTtcbn07XG5cbmNvbnN0IERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGRheSBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIG1vbnRoLlxuICogQHBhcmFtIHllYXIgdGhlIHllYXJcbiAqIEBwYXJhbSBtb250aCB0aGUgbW9udGggKDAtaW5kZXhlZClcbiAqIEBwYXJhbSBkYXkgdGhlIGRheSBvZiB0aGUgbW9udGhcbiAqL1xuY29uc3QgdmFsaWRhdGVEYXlPZk1vbnRoID0gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpID0+IHtcbiAgbGV0IG1heERheXMgPSBEQVlTX0lOX01PTlRIW21vbnRoXTtcbiAgaWYgKG1vbnRoID09PSAxICYmIGlzTGVhcFllYXIoeWVhcikpIHtcbiAgICBtYXhEYXlzID0gMjk7XG4gIH1cblxuICBpZiAoZGF5ID4gbWF4RGF5cykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGF5IGZvciAke01PTlRIU1ttb250aF19IGluICR7eWVhcn06ICR7ZGF5fWApO1xuICB9XG59O1xuXG5jb25zdCBpc0xlYXBZZWFyID0gKHllYXI6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59O1xuXG5jb25zdCBwYXJzZURhdGVWYWx1ZSA9ICh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICBjb25zdCBkYXRlVmFsID0gc3RyaWN0UGFyc2VCeXRlKHN0cmlwTGVhZGluZ1plcm9lcyh2YWx1ZSkpITtcbiAgaWYgKGRhdGVWYWwgPCBsb3dlciB8fCBkYXRlVmFsID4gdXBwZXIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R5cGV9IG11c3QgYmUgYmV0d2VlbiAke2xvd2VyfSBhbmQgJHt1cHBlcn0sIGluY2x1c2l2ZWApO1xuICB9XG4gIHJldHVybiBkYXRlVmFsO1xufTtcblxuY29uc3QgcGFyc2VNaWxsaXNlY29uZHMgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IG51bWJlciA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RyaWN0UGFyc2VGbG9hdDMyKFwiMC5cIiArIHZhbHVlKSEgKiAxMDAwO1xufTtcblxuY29uc3Qgc3RyaXBMZWFkaW5nWmVyb2VzID0gKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IHZhbHVlLmxlbmd0aCAtIDEgJiYgdmFsdWUuY2hhckF0KGlkeCkgPT09IFwiMFwiKSB7XG4gICAgaWR4Kys7XG4gIH1cbiAgaWYgKGlkeCA9PT0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuc2xpY2UoaWR4KTtcbn07XG4iXX0=