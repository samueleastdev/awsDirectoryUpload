"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
const parse_utils_1 = require("./parse-utils");
// Build indexes outside so we allocate them once.
const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
// These must be kept in order
// prettier-ignore
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
/**
 * Builds a proper UTC HttpDate timestamp from a Date object
 * since not all environments will have this as the expected
 * format.
 *
 * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString
 * > Prior to ECMAScript 2018, the format of the return value
 * > varied according to the platform. The most common return
 * > value was an RFC-1123 formatted date stamp, which is a
 * > slightly updated version of RFC-822 date stamps.
 */
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    // Build 0 prefixed strings for contents that need to be
    // two digits and where we get an integer back.
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
exports.dateToUtcString = dateToUtcString;
const RFC3339 = new RegExp(/^(?<Y>\d{4})-(?<M>\d{2})-(?<D>\d{2})[tT](?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))?[zZ]$/);
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC
 * offset. Fractional precision is supported.
 *
 * {@see https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match || !match.groups) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const year = parse_utils_1.strictParseShort(stripLeadingZeroes(match.groups["Y"]));
    const month = parseDateValue(match.groups["M"], "month", 1, 12);
    const day = parseDateValue(match.groups["D"], "day", 1, 31);
    return buildDate(year, month, day, match);
};
exports.parseRfc3339DateTime = parseRfc3339DateTime;
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (?<D>\d{2}) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<Y>\d{4}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (?<D>\d{2})-(?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(?<Y>\d{2}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (?<M>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<D> [1-9]|\d{2}) (?<H>\d{2}):(?<m>\d{2}):(?<s>\d{2})(?:\.(?<frac>\d+))? (?<Y>\d{4})$/);
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 IMF-fixdate or obs-date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * {@see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    //allow customization of day parsing for asctime days, which can be left-padded with spaces
    let dayFn = (value) => parseDateValue(value, "day", 1, 31);
    //all formats other than RFC 850 use a four-digit year
    let yearFn = (value) => parse_utils_1.strictParseShort(stripLeadingZeroes(value));
    //RFC 850 dates need post-processing to adjust year values if they are too far in the future
    let dateAdjustmentFn = (value) => value;
    let match = IMF_FIXDATE.exec(value);
    if (!match || !match.groups) {
        match = RFC_850_DATE.exec(value);
        if (match && match.groups) {
            // RFC 850 dates use 2-digit years. So we parse the year specifically,
            // and then once we've constructed the entire date, we adjust it if the resultant date
            // is too far in the future.
            yearFn = parseTwoDigitYear;
            dateAdjustmentFn = adjustRfc850Year;
        }
        else {
            match = ASC_TIME.exec(value);
            if (match && match.groups) {
                dayFn = (value) => parseDateValue(value.trimLeft(), "day", 1, 31);
            }
            else {
                throw new TypeError("Invalid RFC-7231 date-time value");
            }
        }
    }
    const year = yearFn(match.groups["Y"]);
    const month = parseMonthByShortName(match.groups["M"]);
    const day = dayFn(match.groups["D"]);
    return dateAdjustmentFn(buildDate(year, month, day, match));
};
exports.parseRfc7231DateTime = parseRfc7231DateTime;
/**
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value the value to parse
 * @return a Date or undefined
 */
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = parse_utils_1.strictParseDouble(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
exports.parseEpochTimestamp = parseEpochTimestamp;
/**
 * Build a date from a numeric year, month, date, and an match with named groups
 * "H", "m", s", and "frac", representing hours, minutes, seconds, and optional fractional seconds.
 * @param year numeric year
 * @param month numeric month, 1-indexed
 * @param day numeric year
 * @param match match with groups "H", "m", s", and "frac"
 */
const buildDate = (year, month, day, match) => {
    const adjustedMonth = month - 1; // JavaScript, and our internal data structures, expect 0-indexed months
    validateDayOfMonth(year, adjustedMonth, day);
    // Adjust month down by 1
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(match.groups["H"], "hour", 0, 23), parseDateValue(match.groups["m"], "minute", 0, 59), 
    // seconds can go up to 60 for leap seconds
    parseDateValue(match.groups["s"], "seconds", 0, 60), parseMilliseconds(match.groups["frac"])));
};
/**
 * RFC 850 dates use a 2-digit year; start with the assumption that if it doesn't
 * match the current year, then it's a date in the future, then let adjustRfc850Year adjust
 * the final date back to the past if it's too far in the future.
 *
 * Example: in 2021, start with the assumption that '11' is '2111', and that '22' is '2022'.
 * adjustRfc850Year will adjust '11' to 2011, (as 2111 is more than 50 years in the future),
 * but keep '22' as 2022. in 2099, '11' will represent '2111', but '98' should be '2098'.
 * There's no description of an RFC 850 date being considered too far in the past in RFC-7231,
 * so it's entirely possible that 2011 is a valid interpretation of '11' in 2099.
 * @param value the 2 digit year to parse
 * @return number a year that is equal to or greater than the current UTC year
 */
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + parse_utils_1.strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        // This may end up returning a year that adjustRfc850Year turns back by 100.
        // That's fine! We don't know the other components of the date yet, so there are
        // boundary conditions that only adjustRfc850Year can handle.
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
/**
 * Adjusts the year value found in RFC 850 dates according to the rules
 * expressed in RFC7231, which state:
 *
 * <blockquote>Recipients of a timestamp value in rfc850-date format, which uses a
 * two-digit year, MUST interpret a timestamp that appears to be more
 * than 50 years in the future as representing the most recent year in
 * the past that had the same last two digits.</blockquote>
 *
 * @param input a Date that assumes the two-digit year was in the future
 * @return a Date that is in the past if input is > 50 years in the future
 */
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/**
 * Validate the day is valid for the given month.
 * @param year the year
 * @param month the month (0-indexed)
 * @param day the day of the month
 */
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = parse_utils_1.strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return parse_utils_1.strictParseFloat32("0." + value) * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS11dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYXRlLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtDQUF5RztBQUV6RyxrREFBa0Q7QUFDbEQsTUFBTSxJQUFJLEdBQWtCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFFOUUsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQixNQUFNLE1BQU0sR0FBa0IsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRW5IOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixlQUFlLENBQUMsSUFBVTtJQUN4QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDbkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2pDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDeEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3BDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN4QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFFeEMsd0RBQXdEO0lBQ3hELCtDQUErQztJQUMvQyxNQUFNLGdCQUFnQixHQUFHLGFBQWEsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdB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SyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ3pDLE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFFRCxPQUFPLGdDQUFrQixDQUFDLElBQUksR0FBRyxLQUFLLENBQUUsR0FBRyxJQUFJLENBQUM7QUFDbEQsQ0FBQyxDQUFDO0FBRUYsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEtBQWEsRUFBVSxFQUFFO0lBQ25ELElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNaLE9BQU8sR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFO1FBQzFELEdBQUcsRUFBRSxDQUFDO0tBQ1A7SUFDRCxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7UUFDYixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmljdFBhcnNlQnl0ZSwgc3RyaWN0UGFyc2VEb3VibGUsIHN0cmljdFBhcnNlRmxvYXQzMiwgc3RyaWN0UGFyc2VTaG9ydCB9IGZyb20gXCIuL3BhcnNlLXV0aWxzXCI7XG5cbi8vIEJ1aWxkIGluZGV4ZXMgb3V0c2lkZSBzbyB3ZSBhbGxvY2F0ZSB0aGVtIG9uY2UuXG5jb25zdCBEQVlTOiBBcnJheTxTdHJpbmc+ID0gW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdO1xuXG4vLyBUaGVzZSBtdXN0IGJlIGtlcHQgaW4gb3JkZXJcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgTU9OVEhTOiBBcnJheTxTdHJpbmc+ID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xuXG4vKipcbiAqIEJ1aWxkcyBhIHByb3BlciBVVEMgSHR0cERhdGUgdGltZXN0YW1wIGZyb20gYSBEYXRlIG9iamVjdFxuICogc2luY2Ugbm90IGFsbCBlbnZpcm9ubWVudHMgd2lsbCBoYXZlIHRoaXMgYXMgdGhlIGV4cGVjdGVkXG4gKiBmb3JtYXQuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvVVRDU3RyaW5nXG4gKiA+IFByaW9yIHRvIEVDTUFTY3JpcHQgMjAxOCwgdGhlIGZvcm1hdCBvZiB0aGUgcmV0dXJuIHZhbHVlXG4gKiA+IHZhcmllZCBhY2NvcmRpbmcgdG8gdGhlIHBsYXRmb3JtLiBUaGUgbW9zdCBjb21tb24gcmV0dXJuXG4gKiA+IHZhbHVlIHdhcyBhbiBSRkMtMTEyMyBmb3JtYXR0ZWQgZGF0ZSBzdGFtcCwgd2hpY2ggaXMgYVxuICogPiBzbGlnaHRseSB1cGRhdGVkIHZlcnNpb24gb2YgUkZDLTgyMiBkYXRlIHN0YW1wcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUb1V0Y1N0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgY29uc3QgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gIGNvbnN0IGRheU9mV2VlayA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gIGNvbnN0IGRheU9mTW9udGhJbnQgPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgY29uc3QgaG91cnNJbnQgPSBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gIGNvbnN0IG1pbnV0ZXNJbnQgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgY29uc3Qgc2Vjb25kc0ludCA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuXG4gIC8vIEJ1aWxkIDAgcHJlZml4ZWQgc3RyaW5ncyBmb3IgY29udGVudHMgdGhhdCBuZWVkIHRvIGJlXG4gIC8vIHR3byBkaWdpdHMgYW5kIHdoZXJlIHdlIGdldCBhbiBpbnRlZ2VyIGJhY2suXG4gIGNvbnN0IGRheU9mTW9udGhTdHJpbmcgPSBkYXlPZk1vbnRoSW50IDwgMTAgPyBgMCR7ZGF5T2ZNb250aEludH1gIDogYCR7ZGF5T2ZNb250aEludH1gO1xuICBjb25zdCBob3Vyc1N0cmluZyA9IGhvdXJzSW50IDwgMTAgPyBgMCR7aG91cnNJbnR9YCA6IGAke2hvdXJzSW50fWA7XG4gIGNvbnN0IG1pbnV0ZXNTdHJpbmcgPSBtaW51dGVzSW50IDwgMTAgPyBgMCR7bWludXRlc0ludH1gIDogYCR7bWludXRlc0ludH1gO1xuICBjb25zdCBzZWNvbmRzU3RyaW5nID0gc2Vjb25kc0ludCA8IDEwID8gYDAke3NlY29uZHNJbnR9YCA6IGAke3NlY29uZHNJbnR9YDtcblxuICByZXR1cm4gYCR7REFZU1tkYXlPZldlZWtdfSwgJHtkYXlPZk1vbnRoU3RyaW5nfSAke01PTlRIU1ttb250aF19ICR7eWVhcn0gJHtob3Vyc1N0cmluZ306JHttaW51dGVzU3RyaW5nfToke3NlY29uZHNTdHJpbmd9IEdNVGA7XG59XG5cbmNvbnN0IFJGQzMzMzkgPSBuZXcgUmVnRXhwKFxuICAvXig/PFk+XFxkezR9KS0oPzxNPlxcZHsyfSktKD88RD5cXGR7Mn0pW3RUXSg/PEg+XFxkezJ9KTooPzxtPlxcZHsyfSk6KD88cz5cXGR7Mn0pKD86XFwuKD88ZnJhYz5cXGQrKSk/W3paXSQvXG4pO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSBEYXRlLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgaW5wdXQgaXMgbnVsbCBvclxuICogdW5kZWZpbmVkLCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGlucHV0IGlzIG5vdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBwYXJzZWRcbiAqIGFzIGFuIFJGQyAzMzM5IGRhdGUuXG4gKlxuICogSW5wdXQgc3RyaW5ncyBtdXN0IGNvbmZvcm0gdG8gUkZDMzMzOSBzZWN0aW9uIDUuNiwgYW5kIGNhbm5vdCBoYXZlIGEgVVRDXG4gKiBvZmZzZXQuIEZyYWN0aW9uYWwgcHJlY2lzaW9uIGlzIHN1cHBvcnRlZC5cbiAqXG4gKiB7QHNlZSBodHRwczovL3htbDJyZmMudG9vbHMuaWV0Zi5vcmcvcHVibGljL3JmYy9odG1sL3JmYzMzMzkuaHRtbCNhbmNob3IxNH1cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIGEgRGF0ZSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlUmZjMzMzOURhdGVUaW1lID0gKHZhbHVlOiB1bmtub3duKTogRGF0ZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJGQy0zMzM5IGRhdGUtdGltZXMgbXVzdCBiZSBleHByZXNzZWQgYXMgc3RyaW5nc1wiKTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IFJGQzMzMzkuZXhlYyh2YWx1ZSk7XG4gIGlmICghbWF0Y2ggfHwgIW1hdGNoLmdyb3Vwcykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFJGQy0zMzM5IGRhdGUtdGltZSB2YWx1ZVwiKTtcbiAgfVxuICBjb25zdCB5ZWFyID0gc3RyaWN0UGFyc2VTaG9ydChzdHJpcExlYWRpbmdaZXJvZXMobWF0Y2guZ3JvdXBzW1wiWVwiXSkpITtcbiAgY29uc3QgbW9udGggPSBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHNbXCJNXCJdLCBcIm1vbnRoXCIsIDEsIDEyKTtcbiAgY29uc3QgZGF5ID0gcGFyc2VEYXRlVmFsdWUobWF0Y2guZ3JvdXBzW1wiRFwiXSwgXCJkYXlcIiwgMSwgMzEpO1xuXG4gIHJldHVybiBidWlsZERhdGUoeWVhciwgbW9udGgsIGRheSwgbWF0Y2gpO1xufTtcblxuY29uc3QgSU1GX0ZJWERBVEUgPSBuZXcgUmVnRXhwKFxuICAvXig/Ok1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksICg/PEQ+XFxkezJ9KSAoPzxNPkphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoPzxZPlxcZHs0fSkgKD88SD5cXGR7Mn0pOig/PG0+XFxkezJ9KTooPzxzPlxcZHsyfSkoPzpcXC4oPzxmcmFjPlxcZCspKT8gR01UJC9cbik7XG5jb25zdCBSRkNfODUwX0RBVEUgPSBuZXcgUmVnRXhwKFxuICAvXig/Ok1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKD88RD5cXGR7Mn0pLSg/PE0+SmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLSg/PFk+XFxkezJ9KSAoPzxIPlxcZHsyfSk6KD88bT5cXGR7Mn0pOig/PHM+XFxkezJ9KSg/OlxcLig/PGZyYWM+XFxkKykpPyBHTVQkL1xuKTtcbmNvbnN0IEFTQ19USU1FID0gbmV3IFJlZ0V4cChcbiAgL14oPzpNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pICg/PE0+SmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICg/PEQ+IFsxLTldfFxcZHsyfSkgKD88SD5cXGR7Mn0pOig/PG0+XFxkezJ9KTooPzxzPlxcZHsyfSkoPzpcXC4oPzxmcmFjPlxcZCspKT8gKD88WT5cXGR7NH0pJC9cbik7XG5cbi8qKlxuICogUGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGUuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBpcyBudWxsIG9yXG4gKiB1bmRlZmluZWQsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgaXMgbm90IGEgc3RyaW5nIHRoYXQgY2FuIGJlIHBhcnNlZFxuICogYXMgYW4gUkZDIDcyMzEgSU1GLWZpeGRhdGUgb3Igb2JzLWRhdGUuXG4gKlxuICogSW5wdXQgc3RyaW5ncyBtdXN0IGNvbmZvcm0gdG8gUkZDNzIzMSBzZWN0aW9uIDcuMS4xLjEuIEZyYWN0aW9uYWwgc2Vjb25kcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIHtAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzIzMS5odG1sI3NlY3Rpb24tNy4xLjEuMX1cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIGEgRGF0ZSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlUmZjNzIzMURhdGVUaW1lID0gKHZhbHVlOiB1bmtub3duKTogRGF0ZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJGQy03MjMxIGRhdGUtdGltZXMgbXVzdCBiZSBleHByZXNzZWQgYXMgc3RyaW5nc1wiKTtcbiAgfVxuXG4gIC8vYWxsb3cgY3VzdG9taXphdGlvbiBvZiBkYXkgcGFyc2luZyBmb3IgYXNjdGltZSBkYXlzLCB3aGljaCBjYW4gYmUgbGVmdC1wYWRkZWQgd2l0aCBzcGFjZXNcbiAgbGV0IGRheUZuOiAodmFsdWU6IHN0cmluZykgPT4gbnVtYmVyID0gKHZhbHVlKSA9PiBwYXJzZURhdGVWYWx1ZSh2YWx1ZSwgXCJkYXlcIiwgMSwgMzEpO1xuXG4gIC8vYWxsIGZvcm1hdHMgb3RoZXIgdGhhbiBSRkMgODUwIHVzZSBhIGZvdXItZGlnaXQgeWVhclxuICBsZXQgeWVhckZuOiAodmFsdWU6IHN0cmluZykgPT4gbnVtYmVyID0gKHZhbHVlOiBzdHJpbmcpID0+IHN0cmljdFBhcnNlU2hvcnQoc3RyaXBMZWFkaW5nWmVyb2VzKHZhbHVlKSkhO1xuICAvL1JGQyA4NTAgZGF0ZXMgbmVlZCBwb3N0LXByb2Nlc3NpbmcgdG8gYWRqdXN0IHllYXIgdmFsdWVzIGlmIHRoZXkgYXJlIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZVxuICBsZXQgZGF0ZUFkanVzdG1lbnRGbjogKHZhbHVlOiBEYXRlKSA9PiBEYXRlID0gKHZhbHVlKSA9PiB2YWx1ZTtcblxuICBsZXQgbWF0Y2ggPSBJTUZfRklYREFURS5leGVjKHZhbHVlKTtcbiAgaWYgKCFtYXRjaCB8fCAhbWF0Y2guZ3JvdXBzKSB7XG4gICAgbWF0Y2ggPSBSRkNfODUwX0RBVEUuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmdyb3Vwcykge1xuICAgICAgLy8gUkZDIDg1MCBkYXRlcyB1c2UgMi1kaWdpdCB5ZWFycy4gU28gd2UgcGFyc2UgdGhlIHllYXIgc3BlY2lmaWNhbGx5LFxuICAgICAgLy8gYW5kIHRoZW4gb25jZSB3ZSd2ZSBjb25zdHJ1Y3RlZCB0aGUgZW50aXJlIGRhdGUsIHdlIGFkanVzdCBpdCBpZiB0aGUgcmVzdWx0YW50IGRhdGVcbiAgICAgIC8vIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHllYXJGbiA9IHBhcnNlVHdvRGlnaXRZZWFyO1xuICAgICAgZGF0ZUFkanVzdG1lbnRGbiA9IGFkanVzdFJmYzg1MFllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gQVNDX1RJTUUuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guZ3JvdXBzKSB7XG4gICAgICAgIGRheUZuID0gKHZhbHVlKSA9PiBwYXJzZURhdGVWYWx1ZSh2YWx1ZS50cmltTGVmdCgpLCBcImRheVwiLCAxLCAzMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBSRkMtNzIzMSBkYXRlLXRpbWUgdmFsdWVcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgeWVhciA9IHllYXJGbihtYXRjaC5ncm91cHNbXCJZXCJdKTtcbiAgY29uc3QgbW9udGggPSBwYXJzZU1vbnRoQnlTaG9ydE5hbWUobWF0Y2guZ3JvdXBzW1wiTVwiXSk7XG4gIGNvbnN0IGRheSA9IGRheUZuKG1hdGNoLmdyb3Vwc1tcIkRcIl0pO1xuICByZXR1cm4gZGF0ZUFkanVzdG1lbnRGbihidWlsZERhdGUoeWVhciwgbW9udGgsIGRheSwgbWF0Y2gpKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgdmFsdWUgaW50byBhIERhdGUuIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBpcyBudWxsIG9yXG4gKiB1bmRlZmluZWQsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgaXMgbm90IGEgbnVtYmVyIG9yIGEgcGFyc2VhYmxlIHN0cmluZy5cbiAqXG4gKiBJbnB1dCBzdHJpbmdzIG11c3QgYmUgYW4gaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCBudW1iZXIuIEZyYWN0aW9uYWwgc2Vjb25kcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcGFyc2VcbiAqIEByZXR1cm4gYSBEYXRlIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgY29uc3QgcGFyc2VFcG9jaFRpbWVzdGFtcCA9ICh2YWx1ZTogdW5rbm93bik6IERhdGUgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBsZXQgdmFsdWVBc0RvdWJsZTogbnVtYmVyO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFsdWVBc0RvdWJsZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbHVlQXNEb3VibGUgPSBzdHJpY3RQYXJzZURvdWJsZSh2YWx1ZSkhO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFcG9jaCB0aW1lc3RhbXBzIG11c3QgYmUgZXhwcmVzc2VkIGFzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgb3IgdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uXCIpO1xuICB9XG5cbiAgaWYgKE51bWJlci5pc05hTih2YWx1ZUFzRG91YmxlKSB8fCB2YWx1ZUFzRG91YmxlID09PSBJbmZpbml0eSB8fCB2YWx1ZUFzRG91YmxlID09PSAtSW5maW5pdHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXBvY2ggdGltZXN0YW1wcyBtdXN0IGJlIHZhbGlkLCBub24tSW5maW5pdGUsIG5vbi1OYU4gbnVtZXJpY3NcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKE1hdGgucm91bmQodmFsdWVBc0RvdWJsZSAqIDEwMDApKTtcbn07XG5cbi8qKlxuICogQnVpbGQgYSBkYXRlIGZyb20gYSBudW1lcmljIHllYXIsIG1vbnRoLCBkYXRlLCBhbmQgYW4gbWF0Y2ggd2l0aCBuYW1lZCBncm91cHNcbiAqIFwiSFwiLCBcIm1cIiwgc1wiLCBhbmQgXCJmcmFjXCIsIHJlcHJlc2VudGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG9wdGlvbmFsIGZyYWN0aW9uYWwgc2Vjb25kcy5cbiAqIEBwYXJhbSB5ZWFyIG51bWVyaWMgeWVhclxuICogQHBhcmFtIG1vbnRoIG51bWVyaWMgbW9udGgsIDEtaW5kZXhlZFxuICogQHBhcmFtIGRheSBudW1lcmljIHllYXJcbiAqIEBwYXJhbSBtYXRjaCBtYXRjaCB3aXRoIGdyb3VwcyBcIkhcIiwgXCJtXCIsIHNcIiwgYW5kIFwiZnJhY1wiXG4gKi9cbmNvbnN0IGJ1aWxkRGF0ZSA9ICh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBtYXRjaDogUmVnRXhwTWF0Y2hBcnJheSk6IERhdGUgPT4ge1xuICBjb25zdCBhZGp1c3RlZE1vbnRoID0gbW9udGggLSAxOyAvLyBKYXZhU2NyaXB0LCBhbmQgb3VyIGludGVybmFsIGRhdGEgc3RydWN0dXJlcywgZXhwZWN0IDAtaW5kZXhlZCBtb250aHNcbiAgdmFsaWRhdGVEYXlPZk1vbnRoKHllYXIsIGFkanVzdGVkTW9udGgsIGRheSk7XG4gIC8vIEFkanVzdCBtb250aCBkb3duIGJ5IDFcbiAgcmV0dXJuIG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgeWVhcixcbiAgICAgIGFkanVzdGVkTW9udGgsXG4gICAgICBkYXksXG4gICAgICBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHMhW1wiSFwiXSEsIFwiaG91clwiLCAwLCAyMyksXG4gICAgICBwYXJzZURhdGVWYWx1ZShtYXRjaC5ncm91cHMhW1wibVwiXSEsIFwibWludXRlXCIsIDAsIDU5KSxcbiAgICAgIC8vIHNlY29uZHMgY2FuIGdvIHVwIHRvIDYwIGZvciBsZWFwIHNlY29uZHNcbiAgICAgIHBhcnNlRGF0ZVZhbHVlKG1hdGNoLmdyb3VwcyFbXCJzXCJdISwgXCJzZWNvbmRzXCIsIDAsIDYwKSxcbiAgICAgIHBhcnNlTWlsbGlzZWNvbmRzKG1hdGNoLmdyb3VwcyFbXCJmcmFjXCJdKVxuICAgIClcbiAgKTtcbn07XG5cbi8qKlxuICogUkZDIDg1MCBkYXRlcyB1c2UgYSAyLWRpZ2l0IHllYXI7IHN0YXJ0IHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpZiBpdCBkb2Vzbid0XG4gKiBtYXRjaCB0aGUgY3VycmVudCB5ZWFyLCB0aGVuIGl0J3MgYSBkYXRlIGluIHRoZSBmdXR1cmUsIHRoZW4gbGV0IGFkanVzdFJmYzg1MFllYXIgYWRqdXN0XG4gKiB0aGUgZmluYWwgZGF0ZSBiYWNrIHRvIHRoZSBwYXN0IGlmIGl0J3MgdG9vIGZhciBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEV4YW1wbGU6IGluIDIwMjEsIHN0YXJ0IHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCAnMTEnIGlzICcyMTExJywgYW5kIHRoYXQgJzIyJyBpcyAnMjAyMicuXG4gKiBhZGp1c3RSZmM4NTBZZWFyIHdpbGwgYWRqdXN0ICcxMScgdG8gMjAxMSwgKGFzIDIxMTEgaXMgbW9yZSB0aGFuIDUwIHllYXJzIGluIHRoZSBmdXR1cmUpLFxuICogYnV0IGtlZXAgJzIyJyBhcyAyMDIyLiBpbiAyMDk5LCAnMTEnIHdpbGwgcmVwcmVzZW50ICcyMTExJywgYnV0ICc5OCcgc2hvdWxkIGJlICcyMDk4Jy5cbiAqIFRoZXJlJ3Mgbm8gZGVzY3JpcHRpb24gb2YgYW4gUkZDIDg1MCBkYXRlIGJlaW5nIGNvbnNpZGVyZWQgdG9vIGZhciBpbiB0aGUgcGFzdCBpbiBSRkMtNzIzMSxcbiAqIHNvIGl0J3MgZW50aXJlbHkgcG9zc2libGUgdGhhdCAyMDExIGlzIGEgdmFsaWQgaW50ZXJwcmV0YXRpb24gb2YgJzExJyBpbiAyMDk5LlxuICogQHBhcmFtIHZhbHVlIHRoZSAyIGRpZ2l0IHllYXIgdG8gcGFyc2VcbiAqIEByZXR1cm4gbnVtYmVyIGEgeWVhciB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBVVEMgeWVhclxuICovXG5jb25zdCBwYXJzZVR3b0RpZ2l0WWVhciA9ICh2YWx1ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgY29uc3QgdGhpc1llYXIgPSBuZXcgRGF0ZSgpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIGNvbnN0IHZhbHVlSW5UaGlzQ2VudHVyeSA9IE1hdGguZmxvb3IodGhpc1llYXIgLyAxMDApICogMTAwICsgc3RyaWN0UGFyc2VTaG9ydChzdHJpcExlYWRpbmdaZXJvZXModmFsdWUpKSE7XG4gIGlmICh2YWx1ZUluVGhpc0NlbnR1cnkgPCB0aGlzWWVhcikge1xuICAgIC8vIFRoaXMgbWF5IGVuZCB1cCByZXR1cm5pbmcgYSB5ZWFyIHRoYXQgYWRqdXN0UmZjODUwWWVhciB0dXJucyBiYWNrIGJ5IDEwMC5cbiAgICAvLyBUaGF0J3MgZmluZSEgV2UgZG9uJ3Qga25vdyB0aGUgb3RoZXIgY29tcG9uZW50cyBvZiB0aGUgZGF0ZSB5ZXQsIHNvIHRoZXJlIGFyZVxuICAgIC8vIGJvdW5kYXJ5IGNvbmRpdGlvbnMgdGhhdCBvbmx5IGFkanVzdFJmYzg1MFllYXIgY2FuIGhhbmRsZS5cbiAgICByZXR1cm4gdmFsdWVJblRoaXNDZW50dXJ5ICsgMTAwO1xuICB9XG4gIHJldHVybiB2YWx1ZUluVGhpc0NlbnR1cnk7XG59O1xuXG5jb25zdCBGSUZUWV9ZRUFSU19JTl9NSUxMSVMgPSA1MCAqIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgeWVhciB2YWx1ZSBmb3VuZCBpbiBSRkMgODUwIGRhdGVzIGFjY29yZGluZyB0byB0aGUgcnVsZXNcbiAqIGV4cHJlc3NlZCBpbiBSRkM3MjMxLCB3aGljaCBzdGF0ZTpcbiAqXG4gKiA8YmxvY2txdW90ZT5SZWNpcGllbnRzIG9mIGEgdGltZXN0YW1wIHZhbHVlIGluIHJmYzg1MC1kYXRlIGZvcm1hdCwgd2hpY2ggdXNlcyBhXG4gKiB0d28tZGlnaXQgeWVhciwgTVVTVCBpbnRlcnByZXQgYSB0aW1lc3RhbXAgdGhhdCBhcHBlYXJzIHRvIGJlIG1vcmVcbiAqIHRoYW4gNTAgeWVhcnMgaW4gdGhlIGZ1dHVyZSBhcyByZXByZXNlbnRpbmcgdGhlIG1vc3QgcmVjZW50IHllYXIgaW5cbiAqIHRoZSBwYXN0IHRoYXQgaGFkIHRoZSBzYW1lIGxhc3QgdHdvIGRpZ2l0cy48L2Jsb2NrcXVvdGU+XG4gKlxuICogQHBhcmFtIGlucHV0IGEgRGF0ZSB0aGF0IGFzc3VtZXMgdGhlIHR3by1kaWdpdCB5ZWFyIHdhcyBpbiB0aGUgZnV0dXJlXG4gKiBAcmV0dXJuIGEgRGF0ZSB0aGF0IGlzIGluIHRoZSBwYXN0IGlmIGlucHV0IGlzID4gNTAgeWVhcnMgaW4gdGhlIGZ1dHVyZVxuICovXG5jb25zdCBhZGp1c3RSZmM4NTBZZWFyID0gKGlucHV0OiBEYXRlKTogRGF0ZSA9PiB7XG4gIGlmIChpbnB1dC5nZXRUaW1lKCkgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IEZJRlRZX1lFQVJTX0lOX01JTExJUykge1xuICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgIERhdGUuVVRDKFxuICAgICAgICBpbnB1dC5nZXRVVENGdWxsWWVhcigpIC0gMTAwLFxuICAgICAgICBpbnB1dC5nZXRVVENNb250aCgpLFxuICAgICAgICBpbnB1dC5nZXRVVENEYXRlKCksXG4gICAgICAgIGlucHV0LmdldFVUQ0hvdXJzKCksXG4gICAgICAgIGlucHV0LmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgaW5wdXQuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBpbnB1dC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgcGFyc2VNb250aEJ5U2hvcnROYW1lID0gKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBjb25zdCBtb250aElkeCA9IE1PTlRIUy5pbmRleE9mKHZhbHVlKTtcbiAgaWYgKG1vbnRoSWR4IDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbW9udGg6ICR7dmFsdWV9YCk7XG4gIH1cbiAgcmV0dXJuIG1vbnRoSWR4ICsgMTtcbn07XG5cbmNvbnN0IERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGRheSBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIG1vbnRoLlxuICogQHBhcmFtIHllYXIgdGhlIHllYXJcbiAqIEBwYXJhbSBtb250aCB0aGUgbW9udGggKDAtaW5kZXhlZClcbiAqIEBwYXJhbSBkYXkgdGhlIGRheSBvZiB0aGUgbW9udGhcbiAqL1xuY29uc3QgdmFsaWRhdGVEYXlPZk1vbnRoID0gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpID0+IHtcbiAgbGV0IG1heERheXMgPSBEQVlTX0lOX01PTlRIW21vbnRoXTtcbiAgaWYgKG1vbnRoID09PSAxICYmIGlzTGVhcFllYXIoeWVhcikpIHtcbiAgICBtYXhEYXlzID0gMjk7XG4gIH1cblxuICBpZiAoZGF5ID4gbWF4RGF5cykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGF5IGZvciAke01PTlRIU1ttb250aF19IGluICR7eWVhcn06ICR7ZGF5fWApO1xuICB9XG59O1xuXG5jb25zdCBpc0xlYXBZZWFyID0gKHllYXI6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59O1xuXG5jb25zdCBwYXJzZURhdGVWYWx1ZSA9ICh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICBjb25zdCBkYXRlVmFsID0gc3RyaWN0UGFyc2VCeXRlKHN0cmlwTGVhZGluZ1plcm9lcyh2YWx1ZSkpITtcbiAgaWYgKGRhdGVWYWwgPCBsb3dlciB8fCBkYXRlVmFsID4gdXBwZXIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R5cGV9IG11c3QgYmUgYmV0d2VlbiAke2xvd2VyfSBhbmQgJHt1cHBlcn0sIGluY2x1c2l2ZWApO1xuICB9XG4gIHJldHVybiBkYXRlVmFsO1xufTtcblxuY29uc3QgcGFyc2VNaWxsaXNlY29uZHMgPSAodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IG51bWJlciA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RyaWN0UGFyc2VGbG9hdDMyKFwiMC5cIiArIHZhbHVlKSEgKiAxMDAwO1xufTtcblxuY29uc3Qgc3RyaXBMZWFkaW5nWmVyb2VzID0gKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBsZXQgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IHZhbHVlLmxlbmd0aCAtIDEgJiYgdmFsdWUuY2hhckF0KGlkeCkgPT09IFwiMFwiKSB7XG4gICAgaWR4Kys7XG4gIH1cbiAgaWYgKGlkeCA9PT0gMCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuc2xpY2UoaWR4KTtcbn07XG4iXX0=